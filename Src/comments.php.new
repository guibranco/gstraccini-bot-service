<?php

require_once "config/config.php";

use GuiBranco\GStracciniBot\Library\Codacy;
use GuiBranco\GStracciniBot\Library\CommandHelper;
use GuiBranco\GStracciniBot\Library\LabelHelper;
use GuiBranco\GStracciniBot\Library\LabelService;
use GuiBranco\GStracciniBot\Library\RepositoryManager;
use GuiBranco\GStracciniBot\Library\ProcessingManager;
use GuiBranco\Pancake\GUIDv4;
use GuiBranco\Pancake\Request;
use GuiBranco\Pancake\HealthChecks;

/**
 * Converts a string to camel case format.
 *
 * @param string $inputString The input string to convert
 * @return string The camel case formatted string
 *
 * @throws InvalidArgumentException If the input is not a string
 */
function toCamelCase($inputString)
{
    if (!is_string($inputString)) {
        throw new \InvalidArgumentException('Input must be a string');
    }
    if (empty($inputString)) {
        return '';
    }
    return preg_replace_callback(
        '/(?:^|_| )(\w)/',
        function ($matches) {
            return strtoupper($matches[1]);
        },
        $inputString
    );
}

/**
 * Handles a GitHub comment to determine whether a bot command should be executed.
 * Skips bot comments, validates collaborator status, and triggers the matching command logic.
 *
 * @param object $comment Comment object with properties such as:
 *                        - RepositoryOwner
 *                        - RepositoryName
 *                        - PullRequestNumber
 *                        - CommentId
 *                        - CommentBody
 *                        - CommentSender
 *                        - InstallationId
 *
 * @return void
 */
function handleItem($comment): void
{
    $repoUrl = "https://github.com/{$comment->RepositoryOwner}/{$comment->RepositoryName}/issues/{$comment->PullRequestNumber}/#issuecomment-{$comment->CommentId}";
    echo "{$repoUrl}:\n\n";
    echo "Comment: {$comment->CommentBody} | Sender: {$comment->CommentSender}\n";

    $config = loadConfig();
    $sender = $comment->CommentSender;

    if ($sender === $config->botName . "[bot]") {
        return;
    }

    $ignoredBots = ["github-actions[bot]", "AppVeyorBot", "gitauto-ai[bot]"];
    if (in_array($sender, $ignoredBots, true)) {
        echo "Skipping this comment! ğŸš·\n";
        reactToComment($comment, "-1");
        return;
    }

    $metadata = buildMetadata($comment, $config);

    if (!isCollaborator($comment, $metadata)) {
        if ($sender !== "dependabot[bot]") {
            reactToComment($comment, "-1");
            postComment($metadata, $metadata["errorMessages"]["notCollaborator"]);
        }
        return;
    }

    $pullRequestIsOpen = checkIfPullRequestIsOpen($metadata);
    $executedAtLeastOne = false;

    foreach ($config->commands as $command) {
        $expression = "@" . $config->botName . " " . $command->command;
        if (stripos($comment->CommentBody, $expression) === false) {
            continue;
        }

        $executedAtLeastOne = true;

        if (!empty($command->requiresPullRequestOpen) && !$pullRequestIsOpen) {
            reactToComment($comment, "-1");
            postComment($metadata, $metadata["errorMessages"]["notOpen"]);
            continue;
        }

        $method = "execute_" . toCamelCase($command->command);
        if (is_callable($method)) {
            $method($config, $metadata, $comment);
        } else {
            reactToComment($comment, "-1");
            postComment(
                $metadata,
                sprintf(
                    "%s Command `%s` not implemented. :construction:",
                    $metadata['errorMessages']['notImplemented'],
                    $command->command
                )
            );
        }
    }

    if (!$executedAtLeastOne) {
        postComment($metadata, $metadata["errorMessages"]["commandNotFound"]);
        reactToComment($comment, "-1");
    }
}

/**
 * Sends a reaction emoji to a GitHub comment.
 *
 * @param object $comment  The comment object with RepositoryOwner, RepositoryName, and CommentId.
 * @param string $reaction The GitHub reaction content value (e.g., "+1", "-1", "rocket").
 *
 * @return void
 */
function reactToComment($comment, string $reaction): void
{
    $repoPrefix = "repos/{$comment->RepositoryOwner}/{$comment->RepositoryName}";
    $reactionUrl = "{$repoPrefix}/issues/comments/{$comment->CommentId}/reactions";
    $token = generateInstallationToken($comment->InstallationId, $comment->RepositoryName);

    doRequestGitHub($token, $reactionUrl, ["content" => $reaction], "POST");
}

/**
 * Posts a comment message back to a GitHub issue or PR.
 *
 * @param array  $metadata Metadata array including 'token' and 'commentUrl'.
 * @param string $body     The comment body to send.
 *
 * @return void
 */
function postComment(array $metadata, string $body): void
{
    doRequestGitHub($metadata["token"], $metadata["commentUrl"], ["body" => $body], "POST");
}

/**
 * Checks if the comment sender is a collaborator in the repository.
 *
 * @param object $comment   The comment object with CommentSender and repo identifiers.
 * @param array  $metadata  Metadata containing token and repoPrefix.
 *
 * @return bool True if the user is a collaborator, false otherwise.
 */
function isCollaborator($comment, array $metadata): bool
{
    $collaboratorUrl = $metadata["repoPrefix"] . "/collaborators/" . $comment->CommentSender;
    $response = doRequestGitHub($metadata["token"], $collaboratorUrl, null, "GET");
    $status   = $response->getStatusCode();

    # 204 â†’ collaborator; 404 â†’ not collaborator; anything else â†’ treat as failure / not collaborator
    if ($status === 204) {
        return true;
    }
    if ($status === 404) {
        return false;
    }

    # Log unexpected status codes and fall back to "not collaborator"
    error_log("isCollaborator(): unexpected status {$status} for {$collaboratorUrl}");
    return false;
}

/**
 * Builds a metadata array for use across GitHub API calls and command execution.
 *
 * @param object $comment The comment object with repository and user details.
 * @param object $config  The bot config object (e.g., botName, dashboardUrl).
 *
 * @return array Associative array with token, URLs, and common error messages.
 */
function buildMetadata($comment, $config): array
{
    $repoPrefix = "repos/{$comment->RepositoryOwner}/{$comment->RepositoryName}";
    $prQuery = http_build_query([
        'owner' => $comment->RepositoryOwner,
        'repo' => $comment->RepositoryName,
        'pullRequest' => $comment->PullRequestNumber
    ]);
    $token = generateInstallationToken($comment->InstallationId, $comment->RepositoryName);

    $prefix = "I'm sorry @" . $comment->CommentSender;
    $suffix = ", I can't do that.";
    $emoji = " :pleading_face:";

    return [
        "token" => $token,
        "repoPrefix" => $repoPrefix,
        "repositoryOwner" => $comment->RepositoryOwner,
        "repositoryName" => $comment->RepositoryName,
        "reactionUrl" => "{$repoPrefix}/issues/comments/{$comment->CommentId}/reactions",
        "pullRequestUrl" => "{$repoPrefix}/pulls/{$comment->PullRequestNumber}",
        "issueUrl" => "{$repoPrefix}/issues/{$comment->PullRequestNumber}",
        "commentUrl" => "{$repoPrefix}/issues/{$comment->PullRequestNumber}/comments",
        "labelsUrl" => "{$repoPrefix}/labels",
        "checkRunUrl" => "{$repoPrefix}/check-runs",
        "dashboardUrl" => $config->dashboardUrl . $prQuery,
        "errorMessages" => [
            "notCollaborator" => $prefix . $suffix . " You aren't a collaborator in this repository." . $emoji,
            "invalidParameter" => $prefix . $suffix . " Invalid parameter." . $emoji,
            "notOpen" => $prefix . $suffix . " This pull request is no longer open. :no_entry:",
            "notAllowed" => $prefix . $suffix . " You aren't allowed to use this bot." . $emoji,
            "commandNotFound" => $prefix . $suffix . " Command not found." . $emoji,
            "notImplemented" => $prefix . $suffix . " Feature not implemented yet." . $emoji,
        ]
    ];
}

function execute_help($config, $metadata, $comment): void
{
    doRequestGitHub($metadata["token"], $metadata["reactionUrl"], array("content" => "rocket"), "POST");
    $helpComment = "That's what I can do :neckbeard::\r\n";
    foreach ($config->commands as $command) {
        $parameters = "";
        $parametersHelp = "";
        $prefix = "[ ] ";
        $inDevelopment = isset($command->dev) && $command->dev
            ? " :warning: (In development, it may not work as expected!)"
            : "";
        if (isset($command->parameters)) {
            $prefix = "";
            foreach ($command->parameters as $parameter) {
                $parameters .= " <" . $parameter->parameter . ">";
                $parametersHelp .= "\t- `" . $parameter->parameter . "` - `[" .
                    ($parameter->required ? "required" : "optional") . "]` " .
                    $parameter->description . "\r\n";
            }
        }

        $helpComment .= "- {$prefix}`@{$config->botName} {$command->command}{$parameters}` - ";
        $helpComment .= $command->description . $inDevelopment . "\r\n";
        $helpComment .= $parametersHelp;
    }
    $helpComment .= "\n\nMultiple commands can be issued simultaneously. " .
        "Just respect each command pattern (with bot name prefix + command).\n\n" .
        "> [!NOTE]\n" .
        "> \n" .
        "> If you aren't allowed to use this bot, a reaction with a thumbs down will be added to your comment.\r\n" .
        "\n\n" .
        "> [!TIP]\n" .
        "> \n" .
        "> You can tick (âœ…) one item from the above list, and it will be triggered! (In beta) (Only parameterless commands).\n";
    doRequestGitHub($metadata["token"], $metadata["commentUrl"], array("body" => $helpComment), "POST");
}

function execute_updateVariable($config, $metadata, $comment): void {
    preg_match("/@" . $config->botName . "\\supdate\\svariable\\s([a-zA-Z0-9_-]+)\\s(.+)/", $comment->CommentBody, $matches);

    if (count($matches) !== 3) {
        doRequestGitHub($metadata["token"], $metadata["reactionUrl"], array("content" => "-1"), "POST");
        $body = $metadata["errorMessages"]["invalidParameter"];
        doRequestGitHub($metadata["token"], $metadata["commentUrl"], array("body" => $body), "POST");
        return;
    }

    $name = $matches[1];
    $value = $matches[2];
    $owner = $metadata["repositoryOwner"];
    $repo = $metadata["repositoryName"];

    doRequestGitHub($metadata["token"], $metadata["reactionUrl"], array("content" => "eyes"), "POST");
    $body = "Updating repository variable `{$name}`! :gear:";
    doRequestGitHub($metadata["token"], $metadata["commentUrl"], array("body" => $body), "POST");

    try {
        $response = updateOrCreateRepoVariable($owner, $repo, $name, $value);
        $statusCode = $response->getStatusCode();

        if ($statusCode === 201 || $statusCode === 204) {
            doRequestGitHub($metadata["token"], $metadata["reactionUrl"], array("content" => "rocket"), "POST");
            $action = $statusCode === 201 ? "created" : "updated";
            $body = "Variable '{$name}' has been {$action} successfully! :rocket:";
            doRequestGitHub($metadata["token"], $metadata["commentUrl"], array("body" => $body), "POST");
            return;
        }
        
        doRequestGitHub($metadata["token"], $metadata["reactionUrl"], array("content" => "-1"), "POST");
        $body = "Failed to update variable: Unexpected status code " . $statusCode;
        doRequestGitHub($metadata["token"], $metadata["commentUrl"], array("body" => $body), "POST");
    } catch (Exception $e) {
        doRequestGitHub($metadata["token"], $metadata["reactionUrl"], array("content" => "-1"), "POST");
        doRequestGitHub($metadata["token"], $metadata["commentUrl"], array("body" => "Failed to update variable: " . $e->getMessage()), "POST");
    }
}

function updateOrCreateRepoVariable($owner, $repo, $name, $value)
{
    $request = new Request();
    $url = "https://api.github.com/repos/{$owner}/{$repo}/actions/variables";

    // Get existing variables
    $response = $request->get($url);
    $responseData = json_decode($response->getBody(), true);
    
    if (!isset($responseData['variables'])) {
        throw new Exception("Failed to fetch existing variables");
    }

    $variableExists = false;
    foreach ($responseData['variables'] as $variable) {
        if ($variable['name'] === $name) {
            $variableExists = true;
            break;
        }
    }

    if ($variableExists) {
        $url .= "/{$name}";
        return $request->patch($url, ['value' => $value]);
    } else {
        return $request->post($url, [
            'name' => $name,
            'value' => $value,
            'visibility' => 'all'
        ]);
    }
}

function main(): void
{
    $config = loadConfig();
    ob_start();
    $table = "github_comments";
    global $logger;
    $processor = new ProcessingManager($table, $logger);
    $processor->process('handleItem');
    $result = ob_get_clean();
    if ($config->debug->all === true || $config->debug->comments === true) {
        echo $result;
    }
}

$healthCheck = new HealthChecks($healthChecksIoComments, GUIDv4::random());
$processor = new ProcessingManager("comments", $healthCheck, $logger);
$processor->initialize("handleItem", 55);